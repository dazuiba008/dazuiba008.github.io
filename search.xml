<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TKPROF 使用]]></title>
    <url>%2F2018%2F09%2F21%2FTKPROF-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[话说oracle的剖析工具有很多，这里就介绍下常用的tkprof剖析工具。敲tkprof回车，可以看到提示Usage: tkprof tracefile outputfile [explain= ] [table= ] [print= ] [insert= ] [sys= ] [sort= ] table=schema.tablename Use ‘schema.tablename’ with ‘explain=’ option. explain=user/password Connect to ORACLE and issue EXPLAIN PLAN. print=integer List only the first ‘integer’ SQL statements. aggregate=yes|no insert=filename List SQL statements and data inside INSERT statements. sys=no TKPROF does not list SQL statements run as user SYS. record=filename Record non-recursive statements found in the trace file. waits=yes|no Record summary for any wait events found in the trace file. sort=option Set of zero or more of the following sort options: prscnt number of times parse was called prscpu cpu time parsing prsela elapsed time parsing prsdsk number of disk reads during parse prsqry number of buffers for consistent read during parse prscu number of buffers for current read during parse prsmis number of misses in library cache during parse execnt number of execute was called execpu cpu time spent executing exeela elapsed time executing exedsk number of disk reads during execute exeqry number of buffers for consistent read during execute execu number of buffers for current read during execute exerow number of rows processed during execute exemis number of library cache misses during execute fchcnt number of times fetch was called fchcpu cpu time spent fetching fchela elapsed time fetching fchdsk number of disk reads during fetch fchqry number of buffers for consistent read during fetch fchcu number of buffers for current read during fetch fchrow number of rows fetched userid userid of user that parsed the cursor 参数是挺多的，这里拣几个常用的理解一下吧 explain这里需要输入用户名和密码 ，explain=user/password，得到执行计划和行源信息 table 指定保存执行计划的表 aggregate 是否单独处理同样内容的SQL waits等待事件是否加入到输出文件 sort指定输出文件的SQL顺序 sys=no 就是不看系统的SQL 参数就介绍这些，下面我们介绍下怎么阅读输出的文本信息，这个才是关键，一般都是udump下的trace文件 tkprof skyread_ora_10409.trc /home/oracle/0818.txt sort=prsela,exeela,fchela print=3 explain=yypt/yypt aggregate=no sys=no 这时上面输出的文件，我来解释下图示可以看出trace file的名称，以及sort的方式，这时是unknown session id，一般这里回显示一个session的id，这个头部信息会出现多次，而且在不同的session之间分隔。count：表示执行的数据库调用数量CPU： 提供执行CPU所花的时间单位是秒Elapsed：提供了执行时所花的时间。单位是秒。这个参数值等于用户响应时间Disk：提供缓存区从磁盘读取的数据块量Query：以一致性模式从缓存区获得数据块的数量Current：以当前模式从缓存区获得数据的块数量ROWs： 返回调用或执行调用时，处理的数据行的数量。这里我们做个试验：create table t1 (a int);insert into t1values (1000); commit;alter session set events ‘10046 trace name context forever,level 12’;select * from t1;update t1 t1_1set x=x+1 ;update t1 t1_2 set x=x+1 ;这样我们就对后面三个sql进行了跟踪。tkprof oradb_ora_25204.trc /home/oracle/zhh.txt explain=charge/charge sys=no可以看到上面三条SQL的信息，还有一定要记得只有加上explain参数，才可以看到执行计划哦。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Greenplum install]]></title>
    <url>%2F2013%2F09%2F18%2FGreenplum-install%2F</url>
    <content type="text"><![CDATA[架构：master主要建立与客户端的连接，收集segment的执行结果，不存放业务数据，可以一主一备segment业务数据存放处，执行master分发的SQL,一台机器可以配置多个segment，segment分primary和mirror 四台服务器搭建测试环境 192.168.101.115 master192.168.101.116 segment+standby192.168.100.217 segment192.168.100.225 segment 分辨配置一个primary，一个mirror对应后面参数路径，如果设置多个,空格分隔即可declare -a DATA_DIRECTORY=(/data01/gpadmin/gpdata/primary)declare -a MIRROR_DATA_DIRECTORY=(/data01/gpadmin/gpdata/mirror) 1.每台服务器/etc/hosts192.168.101.115 db-192-168-101-115.sky-mobi.com db-192-168-101-115192.168.101.116 db-192-168-101-116.sky-mobi.com db-192-168-101-116192.168.100.217 db-192-168-100-217.sky-mobi.com db-192-168-100-217192.168.100.225 db-192-168-100-225.sky-mobi.com db-192-168-100-225 2.配置/etc/sysctl.confkernel.shmmax = 500000000kernel.shmmni = 4096kernel.shmall = 4000000000kernel.sem = 250 512000 100 2048kernel.sysrq = 1kernel.core_uses_pid = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.msgmni = 2048net.ipv4.tcp_syncookies = 1net.ipv4.conf.default.accept_source_route = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_max_syn_backlog = 4096net.ipv4.conf.all.arp_filter = 1net.ipv4.ip_local_port_range = 10000 65535net.core.netdev_max_backlog = 10000net.core.rmem_max = 2097152net.core.wmem_max = 2097152vm.overcommit_memory = 2 3.配置/etc/security/limits.conf soft nofile 65536 hard nofile 65536 soft nproc 131072 hard nproc 131072 修改磁盘调度策略echo deadline &gt; /sys/block/sba/queue/scheduler 5.执行安装程序useradd gpadminpasswd gpadminunzip greenplum-db-4.3.12.0-rhel5-x86_64.zip./greenplum-db-4.3.12.0-rhel5-x86_64.bin默认安装在/usr/local下 7.chown -R gpadmin.gpadmin /usr/local/greenplum-db8.配置gpadmin环境变量，添加以下source /usr/local/greenplum-db/greenplum_path.shexport MASTER_DATA_DIRECTORY=/data01/gpadmin/gpdata/master/gpseg-1export PGPORT=1922export PS1=”$USER@/bin/hostname -s-&gt; “ 9.新建两个文件hostlist, seg_hostshostlistdb-192-168-101-115db-192-168-101-116db-192-168-100-217db-192-168-100-225 seg_hostsdb-192-168-101-116db-192-168-100-217db-192-168-100-225 10.使用gpssh-exkeys打通所有服务器的透明登陆gpssh-exkeys -f hostlistgpssh -f hostlist ls //批量执行命令 11.打包安装好的目录，并复制到其他节点，解压tar -cf gp.tar /use/local/greenplum-db-4.3.12.0/gpscp -f hostlist gp.tar =:/home/gpmadin //批量服务到每个节点tar -xf gp.tar //解压 12.建立相关数据目录赋予权限mkdir -p /data01/gpadmin/gpdata/mastermkdir -p /data01/gpadmin/gpdata/primarymkdir -p /data01/gpadmin/gpdata/mirrorchown -R gpadmin.gpadmin /data01/gpadmin/gpdata/master /data01/gpadmin/gpdata/primary /data01/gpadmin/gpdata/mirror 13.初始化Greenplum复制配置文件到自己的目录cp /usr/local/greenplum-db/docs/cli_help/gpconfigs/gpinitsystem_config /home/gpadmin/ 修改后的相关参数ARRAY_NAME=”SKY Greenplum DW”SEG_PREFIX=gpsegPORT_BASE=40000declare -a DATA_DIRECTORY=(/data01/gpadmin/gpdata/primary)MASTER_HOSTNAME=db-192-168-101-115MASTER_DIRECTORY=/data01/gpadmin/gpdata/masterMASTER_PORT=1922TRUSTED_SHELL=sshCHECK_POINT_SEGMENTS=8ENCODING=UTF-8MIRROR_PORT_BASE=50000REPLICATION_PORT_BASE=41000MIRROR_REPLICATION_PORT_BASE=51000declare -a MIRROR_DATA_DIRECTORY=(/data01/gpadmin/gpdata/mirror)MACHINE_LIST_FILE=/home/gpadmin/seg_hosts 初始化GPgpinitsystem -c /home/gpadmin/gpinitsystem_config -s db-192-168-101-116 数据库可以正常连接：psql -d postgrespsql (8.2.15)Type “help” for help. postgres=# \l List of databases Name | Owner | Encoding | Access privileges———–+———+———-+———————— hank | gpadmin | UTF8 | =Tc/gpadmin : gpadmin=CTc/gpadmin : hank=CTc/gpadmin postgres | gpadmin | UTF8 | template0 | gpadmin | UTF8 | =c/gpadmin : gpadmin=CTc/gpadmin template1 | gpadmin | UTF8 | =c/gpadmin : gpadmin=CTc/gpadmin 关闭与启动： gpstart -a 启动 gpstop -a 关闭 gpstop -r 重启 gpstop -u 重载配置参数 gpstart -m 单用户维护模式启动 PGOPTIONS=’-c gp_session_role=utility’ psql gpstate 查看GP状态 参考：http://gpdb.docs.pivotal.io/43120/install_guide/prep_os_install_gpdb.html]]></content>
      <categories>
        <category>Greenplum</category>
      </categories>
      <tags>
        <tag>Greenplum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb replica sets reconfig and conver a Secondary to an Arbiter]]></title>
    <url>%2F2013%2F04%2F22%2Fmongodb-replica-sets-reconfig-and-conver-a-Secondary-to-an-Arbiter%2F</url>
    <content type="text"><![CDATA[replica set由于需求可能会调整节点的优先级，或者仲裁节点那么先看一下语法：rs.reconfig(configuration[, force])Parameters:configuration – A document that specifies the configuration of a replica set.force – Optional. Specify { force: true } as the force parameter to force the replica set to accept the new configuration even if a majority of the members are not accessible. Use with caution, as this can lead to rollback situations.Initializes a new replica set configuration. This function will disconnect the shell briefly and forces a reconnection as the replica set renegotiates which node will be primary. As a result, the shell will display an error even if this command succeeds. rs.reconfig() provides a wrapper around the “replSetReconfig” database command. rs.reconfig() overwrites the existing replica set configuration. Retrieve the current configuration object with rs.conf(), modify the configuration as needed and then use rs.reconfig() to submit the modified configuration object. To reconfigure a replica set, use the following sequence of operations: conf = rs.conf() // modify conf to change configuration rs.reconfig(conf)If you want to force the reconfiguration if a majority of the set isn’t connected to the current member, or you’re issuing the command against a secondary, use the following form: conf = rs.conf() // modify conf to change configuration rs.reconfig(conf, { force: true } )Warning Forcing a rs.reconfig() can lead to rollback situations and other difficult to recover from situations. Exercise caution when using this option.这里遇到rollback情况，可能会导致fatal状态，那么replica set就等于失效了，可以拷贝local数据文件，或者所有数据文件进行重建举例：var c = rs.conf();c.members[2].priority = 0; 0~100数字越大优先级越高，0不会被切换为primary节点，这里也可以写成包含小数的值rs.reconfig(c);配置完以后，可以通过一下命令查看一下配置是否修改好：rs.conf()rs.status()为了防止脑裂，可以加入仲裁节点，使用以下命令：rs.addArb(“:&lt;:port&gt;”); ==rs.add(hostspec, arbiterOnly)示例：rs.add(‘mongodb3.example.net:27017’, true)当然将一个从节点转换为仲裁节点：(1)首先关闭从节点(2)rs.remove(“&lt;:port&gt;”)删除该从节点，rs.conf()验证一下(3)创建新的数据目录，因为仲裁节点是不存放生产数据的(4)通过rs.addArb(“:&lt;:port&gt;”)加入，rs.conf()验证一下那么就可以看到：仲裁节点的属性为”arbiterOnly” : true{ “_id” : “xxx”, “version” : 14, “members” : [ { “_id” : 1, “host” : “xxx.xxx.xxx.xxx:5281” }, { “_id” : 2, “host” : “ xxx.xxx.xxx.xxx :5281”, “arbiterOnly” : true }, { “_id” : 3, “host” : “ xxx.xxx.xxx.xxx :5281” } ]}]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发器限制指定IP访问oracle数据库]]></title>
    <url>%2F2011%2F09%2F21%2F%E8%A7%A6%E5%8F%91%E5%99%A8%E9%99%90%E5%88%B6%E6%8C%87%E5%AE%9AIP%E8%AE%BF%E9%97%AEoracle%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[最近有个项目需要限制某些数据库用户的访问来源IP，在PG中比较好实现，但是ORACLE没有比较简便的操作。如果不管用户的话，仅仅限制来源IP对监听的访问是比较容易实现的，通过配置数据库服务器的sqlnet.ora文件或者修改数据库服务器的IPTABLES等手段实现。123456789101112131415161718192021222324252627sqlnet.ora范例:tcp.validnode_checking=yestcp.invited_nodes=(172.16.33.11,172.16.34.89)iptables范例:[root@kefu ~]# cat /etc/sysconfig/iptables# Firewall configuration written by system-config-securitylevel# Manual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:RH-Firewall-1-INPUT - [0:0]-A INPUT -j RH-Firewall-1-INPUT-A FORWARD -j RH-Firewall-1-INPUT# 允许访问1521的服务器-A RH-Firewall-1-INPUT -s 172.16.3.68/32 -m state --state NEW -m tcp -p tcp --dport 1521 -j ACCEPT-A RH-Firewall-1-INPUT -i lo -j ACCEPT-A RH-Firewall-1-INPUT -p icmp --icmp-type any -j ACCEPT-A RH-Firewall-1-INPUT -p 50 -j ACCEPT-A RH-Firewall-1-INPUT -p 51 -j ACCEPT-A RH-Firewall-1-INPUT -p udp --dport 5353 -d 224.0.0.251 -j ACCEPT-A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT-A RH-Firewall-1-INPUT -p tcp -m tcp --dport 631 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp-host-prohibitedCOMMIT 下面来看看如何限制特定用户和特定IP： 创建ACL表 (本例将ACL表建立在dsm用户下,随便建哪里都可以)1234create table dsm.tbl_iplimit (logonuser varchar2(32),ip_address varchar2(15),remark varchar2(64),create_time date default sysdate);insert into dsm.tbl_iplimit values (&apos;DSM&apos;,&apos;172.16.18.81&apos;,&apos;digoal&apos;&apos;s host.&apos;,sysdate);insert into dsm.tbl_iplimit values (&apos;DSM&apos;,&apos;local&apos;,&apos;本地&apos;,sysdate);commit; 这里限制了DSM用户只能从172.16.18.81和ORACLE所在服务器登录.其他用户不受限制. 创建触发器 1234567891011121314151617181920212223conn / as sysdbacreate or replace trigger &quot;logon_audit&quot; afterlogon on databasedeclarerecord_num number;userip varchar2(15);isforbidden boolean:=true;begin userip:=nvl(sys_context (&apos;userenv&apos;,&apos;ip_address&apos;),&apos;local&apos;); select count(*) into record_num from dsm.tbl_iplimit where logonuser=user; if (record_num&gt;0) then select count(*) into record_num from dsm.tbl_iplimit where logonuser=user and ip_address=userip; if (record_num=0) then raise_application_error(-20003,&apos;ip :&apos;||userip||&apos; is forbided&apos;); end if; end if;exception when value_error then sys.dbms_output.put_line(&apos;exception handed&apos;); when others then raise;end logon_audit;/ 测试 123456789101112131415161718192021222324在本地登录SQL&gt; conn dsm/pwd正常delete from tbl_iplimit where ip_address=&apos;local&apos;;commit;exit;再在本地登录,已经受阻了.SQL&gt; conn dsm/pwdERROR:ORA-00604: error occurred at recursive SQL level 1ORA-20003: ip :local is forbidedORA-06512: at line 18换台机器(172.16.3.67)登录:SQL&gt; conn dsm/pwd@//172.16.3.13:1521/sidERROR:ORA-00604: error occurred at recursive SQL level 1ORA-20003: ip :local is forbidedORA-06512: at line 18受阻换台机器(172.16.3.81)登录:SQL&gt; conn dsm/pwd@//172.16.3.13:1521/sid正常 如果IP范围比较宽，可以写一个IP比较的函数加入到上面的判断中,避免写很多条记录。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle执行计划和执行顺序]]></title>
    <url>%2F2011%2F09%2F21%2Foracle%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[如果要了解执行计划和执行顺序，必须理解执行计划的父子关系。执行计划是一个树状结构，顶层的STATEMENT是这棵树的根。父子关系按照如下的树状结构组织：PARENT FIRST CHILD SECOND CHILD 在这个例子里，FIRST CHILD最先执行，然后是SECOND CHILD，这两个步骤执行完毕后，执行PARENT。下面是一个更多层次的结构： PARENT1 FIRST CHILD FIRST GRANDCHILD SECOND CHILD FIRST GRANDCHILD是第一个执行的步骤，然后是FIRST CHILD。下面通过一个真实的执行计划来验证这个原则： set autotrace traceonly explain select ename,dname from emp, dept where emp.deptno=dept.deptno and dept.dname in (‘ACCOUNTING’,’RESEARCH’,’SALES’,’OPERATIONS’); 15 rows selected. 这个语句的执行计划如下： Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE (Cost=3 Card=8 Bytes=248) 1 0 HASH JOIN (Cost=3 Card=8 Bytes=248) 2 1 TABLE ACCESS (FULL) OF ‘DEPT’ (Cost=1 Card=3 Bytes=36) 3 1 TABLE ACCESS (FULL) OF ‘EMP’ (Cost=1 Card=16 Bytes=304) 注意这个执行计划的最左边的两个列，第一个列是步骤的ID，第二个列是父步骤的ID。执行从ID=0的行开始： 0 SELECT STATEMENT Optimizer=CHOOSE (Cost=3 Card=8 Bytes=248) 这个步骤没有父步骤，有一个子步骤（ID=1），所以这个ID＝1的步骤必须在执行步骤0之前执行。继续观察ID=1的步骤： 1 0 HASH JOIN (Cost=3 Card=8 Bytes=248) 这个步骤是ID=0的步骤的子步骤，该步骤有2个子步骤：ID=2和ID=3，因此ID=2和ID=3的步骤必须在ID=1的步骤之前执行。再来检查ID=2的步骤： 2 1 TABLE ACCESS (FULL) OF ‘DEPT’ (Cost=1 Card=3 Bytes=36) 这个步骤是ID=1的步骤的子步骤，并且该步骤没有任何子步骤。因此该步骤是这个SQL语句第一个执行的步骤，这个步骤产生的结果集会提供给ID=1的步骤。这个步骤是对表DEPT进行全表扫描，这个步骤的COST＝1。 ID=1的步骤也依赖ID=3的步骤： 3 1 TABLE ACCESS (FULL) OF ‘EMP’ (Cost=1 Card=16 Bytes=304) 这个步骤是ID=1的步骤的第二个子步骤，没有任何子步骤，在这个语句中，是第二个被执行的步骤。 ID=1的步骤将ID=3和ID=3的步骤的结果集进行HASH 连接，然后把结果交给ID=0的步骤，就完成了本语句的执行。 这里是转载白鳝大大的一篇文章，对于执行计划读取入门，还是很清楚简单明了的。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈oracle索引]]></title>
    <url>%2F2011%2F09%2F21%2F%E6%B5%85%E8%B0%88oracle%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[oracle索引一般分为B树索引和位图索引，用的比较多的都是B树索引。 B树索引，比如普通索引，反转索引，降序索引，函数索引，这些索引都是B树索引，结构都是一样的，位图索引的存储结构和B树是不一样的，对于B树索引，可以进行一般的索引唯一扫描，索引范围扫描，快速索引扫描和索引全扫描，位图就简单很多，他只有全扫描，才能找到对应的行。顾名思义，B树索引其实就是一棵树，普通的都是升序，右边节点比左边的节点大，那么降序就是正好反之。B树的所有节点都在一条双向链上，就是用来实现范围扫秒用的。 接下来，介绍一下反转索引，反转索引在存储键值的时候，先把键值反转，再进行存储，比如abcd就反转为dcba，一般反转索引用来解决热块，原理就是利用键值反转，把索引块打乱，把热点分散到不同的索引块。 记得创建的时候是用reverse函数：create index_name on tablename (reverse(ind_name));如过是 create index_name on tablename(ind_name) reverse;是用不到范围扫描的。 HW大家应该都清楚，如果是全表扫描，那么所有的数据块都会被扫一遍，HW以下的是肯定被扫的，以上的就不用了，以上的就相当于是没人住过的房子，不用去找。这里B树索引高度一般都是3，就是说扫描三个索引块就可以找到值，如果数据量大，那么可能就会高于3这个高度，B索引重要的几个概念，根节点，分支节点，叶子节点，很好理解，根肯定是最高的，分支就在中间，叶子在最底层，这里注意叶子节点，他除了有键值，还有块地址。 还有一点索引的使用绝对不能滥用，因为索引是有序的，所以在IO上会有很大消耗，如果一个表上很多索引，而且表的内容经常使用DML语句，那么索引肯定也是经常更新，会消耗额外的IO和CPU性能。还有一点一定要记得，创建好函数索引以后，一定要记得分析后再使用。至于反转索引，这里不详解了，可以dump出来看看，在reverse一下看看区别。很明显。 还有索引快速扫和索引扫是不一样的，快速只扫叶子节点，一次性读取db_file_multiblock_read_count个，索引扫是从根开始扫，只读书一个数据块。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[library cache]]></title>
    <url>%2F2011%2F09%2F21%2Flibrary-cache%2F</url>
    <content type="text"><![CDATA[这里简单发表下对库告诉缓存的认识，大家知道共享池是有library cache和data dictionary cache和控制部分组成，首先sql执行的过程显示语法分析阶段，然后是语意分析阶段，也就是验证下对象权限等一些列的东西，再下面就是SQL进行hash运算，运算后匹配library cache里的hash桶，再匹配hash桶上面的handle，也就是句柄，如果匹配成功，那么去找子游标，如果不成功，那么就生成一个handle，这里也就是硬解析，挂载hash桶上。 这里如果是不同用户或者，期间对象权限更改，就算是SQL文本一样，也是无法共享子游标的，生成handle，其实就是要想共享池申请空闲的内存，期间获得shared pool latch ，那么很容易产生冲突。handle其实就是存放的父游标，真正的执行计划是存放在子游标上的，也就是heap6上，一个父游标可能对应多个子游标，比如，不同用户下的相同SQL，就会造成1个父对多个子游标，这种父游标存在，而要重新生成子游标，就是relaod，需要耗硬件资源，数据库性能也就十分低下，所以我们要避免硬解析和reload，解析过程中很消耗资源，而且容易造成 latch的冲突，父游标里主要包含SQL文本，父游标打开时，是被锁住的，也就是不能交换出library cache ，子游标主要包含执行计划和绑定变量，这个就很重要。这里再介绍下软解析，其实只要在hash桶里可以匹配对应的SQL文本，那么就是软解析，说明之前运行过该sql，其实sql执行期间只要步骤可以跳过，那么我们就可以定位为软解析。这里还有软软解析，这个是最好性能，session_cached_cursors，当会话相同的CURSOR第三次访问是，那么会话会在PGA里做个标记，就算会话结束，cursor也不会从library cache交换出去，这里不需要访问library cache，只和PGA有关联，共享的东西这里我们没去访问，也就是不争用资源，性能得到提升。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle内存碎片]]></title>
    <url>%2F2011%2F09%2F21%2Foracle%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[oracle内存碎片是由于频繁的申请，释放，拆分chunk，从而导致拆分成很多小的chunk，这就是内存碎片。碎片有什么危害呢，可能造成shared pool latch的冲突。 我们需要为大的内存需求保留空间，避免申请大chunk的时候，结果没有，申请不到。对于非常大的对象，oracle可以单独保留一个区域为此分配空间，shared_pool_reserved_size，这个值缺省应该是shared_pool_size 的5%，这块区域完全和正常的chunk不相往来，单独存在，v$shared_pool_reserved可以通过这个视图查看这块区域的使用情况。这个区域的管理是先进先出原则，怎么避免内存碎片呢，首先大的对象keep到内存，可以用dbms_shared_pool.keep,具体使用自己研究一下，这里无论是存储对象还是临时的，都可以keep。减少大的匿名块，比如PL/SQL，还有就是避免共享池太大，共享池够用就好，如果共享池很大，小的chunk申请又多，那么就造成很多碎片，freelist就会很长，持有的shared_pool_latch就会时间长，CPU遍历的时候就会很耗资源，所以加大共享池不是解决此种冲突的方法，这个时候最关键的还是看一下为什么不能共享SQL语句。从9I开始，oracle开始引入了多个共享池的概念，所以大的共享池不会再那么差劲，可以最多有7个子latch保护共享池，要配置多个共享池，首先硬件要足够的硬，呵呵。CPU够多，内存够大。比如一个hash桶油18000个chunk，如果只有一个共享池，那么只能遍历这18000个，如果配置了6个子共享池，那么平均一个hash桶就是18000/6，一个shared_pool_latch也就是原来的1/6时间就可以完成。子共享池的个数可以通过隐含参数_kghdsidx_count手动调节，同事也指定了几个child latch，可以通过select a.ksppinm,b.ksppstvl from x$ksppi a,x$ksppsv b where a.indx=b.indx and a.ksppinm=’_kghdsidx_count’;查看你的数据库有几个共享池。看了一下，10G默认的子共享池个数是2个，相对的，增加了共享池，你就可以适当的增加共享池的大小，每个子共享池有自己的LRU列表，和shared_pool_latch.v$db_object_cache存放了钉住的对象信息，或者可以设置cursor_sharing=force.这个设置比较复杂，这里是强制绑定变量，具体以后分解。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux cluster配置安装（简化)]]></title>
    <url>%2F2011%2F09%2F18%2Flinux-cluster%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%EF%BC%88%E7%AE%80%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一:首先先介绍一下服务器配置：两台hp ProLiant DL360 G6 ，配置均一样 两颗四核Intel(R) Xeon(R) CPU E5504 @ 2.00GHz 内存：24G 硬盘：三块146G本地硬盘 二：安装clucster，这一步在安装系统的时候已经选中了cluster组件，如果没有安装，那么安装必要的RPM包三：利用chkconfig –list查看服务，chkconfig –level 35 service off关闭没有必要的服务，节省资源,提高启动速度四：配置集群两台服务器都已经安装redhat5.5 下面是进行一些配置文件的修改 1：首先修改/etc/hosts文件这个文件要求两台机器上均一样 192.168.29.54 pgbouncer-192-168-29-54.sky-mobi.com.hz pgbouncer-192-168-29-54 192.168.29.55 pgbouncer-192-168-29-55.sky-mobi.com.hz pgbouncer-192-168-29-55 192.168.27.8 pgbouncer-192-168-29-55_fence.sky-mobi.com.hz pgbouncer-192-168-29-55_fence 192.168.27.9 pgbouncer-192-168-29-54_fence.sky-mobi.com.hz pgbouncer-192-168-29-54_fence 2:修改内核参数，不同的硬件配置可以根据具体情况进行配置，以下是我加的/etc/sysctl.confnet.ipv4.ip_local_port_range = 1024 65000 net.core.rmem_default = 1048576 net.core.rmem_max = 1048576 net.core.wmem_default = 262144 net.core.wmem_max = 262144 net.ipv4.tcp_tw_recycle=1 net.ipv4.tcp_max_syn_backlog=4096 net.core.netdev_max_backlog=10000 vm.overcommit_memory=0 net.ipv4.ip_conntrack_max=655360 3：配置/etc/security/limits.conf,加入12345678* soft nofile 131072* hard nofile 131072* soft nproc 131072* hard nproc 131072* soft core unlimited* hard core unlimited* soft memlock 50000000* hard memlock 50000000 4：配置/etc/pam.d/login,加入session required pam_limits.so 5：配置/etc/ssh/sshd_config，加入修改UseDNS no 6：配置/etc/sysconfig/ntpd，同步改为SYNC_HWCLOCK=yes 7：配置/etc/rc.local，加入/sbin/sysctl -w net.ipv4.ip_conntrack_max=655360 8：配置/etc/cluster/cluster.conf,截图有点大，大家凑合着看吧，这里其实就是利用system-config-cluster图形配置完成后生成的集群配置文件，这里直接创建并修改这个文件即可，下面简单说明下这个配置：12345678910111213141516171819202122232425Alias这里是集群的名称，大家可以自定义，不过切记在局域网内保证名字唯一性后面config_version是版本，这个大家修改一次，可以加1，两台服务器要一致，name可以和alias一样。接下来就是配置nodeName是主机名，device name是fence名称&lt;fencedevice agent=&quot;fence_ilo&quot; hostname=&quot;pgbouncer-192-168-29-54_fence&quot; login=&quot;cqzx&quot; name=&quot;pgbouncer-192-168-29-54_fence&quot; passwd=&quot;Fj6Ci0xSKbJ&quot;/&gt;这一行是配置fence，这里是用ilo做fence，填入用户名和密码以及名称即可&lt;failoverdomain name=&quot;pgbouncer_failover&quot; ordered=&quot;0&quot; restricted=&quot;1&quot;&gt; &lt;failoverdomainnode name=&quot;pgbouncer-192-168-29-54&quot; priority=&quot;1&quot;/&gt; &lt;failoverdomainnode name=&quot;pgbouncer-192-168-29-55&quot; priority=&quot;1&quot;/&gt;这里是失效域的配置，failoverdomain name自定义，failoverdomainnode name写入fence设备的名称&lt;ip address=&quot;10.0.0.100&quot; monitor_link=&quot;1&quot;/&gt; &lt;script file=&quot;/etc/init.d/nfs&quot; name=&quot;nfs&quot;/&gt;这里配置资源，这里我是NFS服务&lt;script ref=&quot;nfs&quot;/&gt;这里的名称要与上面name的名称一致 9:加入crontabCrontab –e /2 /usr/sbin/ntpdate asia.pool.ntp.org &amp;&amp; /sbin/hwclock –systohc 定时同步时间 10：启动集群服务Service cman start Service rgmanager start 通过clustat查看状态。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ONE PASS AND MULTI PASS]]></title>
    <url>%2F2011%2F08%2F01%2FONE-PASS-AND-MULTI-PASS%2F</url>
    <content type="text"><![CDATA[谈到ONE PASS AND MULTI PASS，那么不得不谈谈oracle sort，不知道大家是不是这么认为，给的内存多了，那么SORT是不是就性能就好了呢？答案肯定是否定的，那么我们先介绍下oracle 的SORT。 其实在数据库环境中，很多时候都是伴随着排序的，比如创建索引，group by ,order by,union，分组函数等等。一般情况下，应该是排序在cache中性能是最好的，完了是ONE pass，最差的就是multi pass，但是这不是绝对的，如果你PGA_AGGREGATE_TARGET一味的加大，排序的性能可能直线下降，比MULTI pass的性能还差，在我们OLAP环境中，不要期望所有的排序都在CACHE中，ONE PASS是我们要调优的重点，因为MULTI PASS性能最差。 这里了解一下排序的机制，排序是私有的，他的排序区是有大小限制的，一次排序超过这个限制了，不得不用到临时表空间。监控排序相关的视图：V$SQL_WORKAREA、V$SQL_WORKAREA_ACTIVE、V$SORT_USAGE，这个大家下去自己查阅联机文档从9i开始，workarea_size_policy 是AMM（自动内存管理）AMM会有一个后台进程每3秒钟为检查负载情况，为每个进程合理的更新最小内存ONE-PASS点，所以要找这个点从9i开始就交给oracle自己完成了，我们不需要再去配置sort_area_size等相关的参数。如果workarea_size_policy 是MANUAL的，那么可以研究一下sort_area_size 相关的参数。总的进程PGA大小是由PGA_AGGREGATE_TARGET决定的，其实排序的时候要维护一个二叉树，如果这个二叉树很大的话，那么很消耗CPU资源。 cache模式：当一个排序进程读取数据源，写到workarea_size_policy 的时候，incoming data和tree没有被填充满就结束了排序的情况，就是cache模式，这种是性能最好的情况。 one-pass模式：当一个排序吧incoming data和tree填充满以后，如果再继续填充，那么会把工作区里面的数据进行分片，叫sort runs，这个排序运行片归档至临时表空间。那么如果排序很大，就会有很多的sort runs，归档到临时表空间的sort runs还的重新进行一次merge，这里有一个基于排序区的宽度（max intermediate merge width），也就是一次merge的宽度，可以通过10032和10033查看这些内容，比如这里有50个sort runs，这个宽度是100，那么我们merge一次就可以完成，这里就叫做one-pass。 multi-pass模式：如果merge一次，不够，需要多次merge。多次merge，肯定增加IO压力。所以这种是效率最差的。 当做工作区是AMM的时候，如果不能cache，那么就要切换到minimum one-pass memeory.这里只介绍几种模式，具体优化以后有时间再续。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle ORA-1555错误]]></title>
    <url>%2F2011%2F07%2F29%2Foracle-ORA-1555%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1555错误大家应该都碰到过，这里做下简单的阐述和一些解决方法。 大家可以这么理解，oracle提交的UNDO超过了保留期，或者在保留期的数据被覆盖，无法做一致性读，就会抛出此类错误，这里有几个参数有必要说明一下： UNDO_MANAGEMENT：值为AUTO表示使用了自动撤销管理表空间，MANUAL则表示手动管理（已淘汰），如果想Flashback Query自动管理必须条件 。 UNDO_TABLESPACE：Oracle数据库中可以创建多个UNDO表空间，不过同时只能使用一个，当UNDO_MANAGEMENT初始化参数值为AUTO时，UNDO_TABLESPACE参数用来指定当前使用的UNDO表空间名称 UNDO_RETENTION：该参数用来指定UNDO段中数据保存的最短时间，以秒为单位，是一个动态参数，完全可以在实例运行时随时修改，通常默认是900秒，其实这个保留时间并不是说超过这个时间就会过期，数据就不在了，只是标记了一下可以被覆盖了，超过这个时间的数据可以被覆盖了，同理，就算是没有超过这个时间，你的UNDO空间已经满了，那么新事务的数据还是会覆盖掉UNDO。那么此时如果你在找丢失部分的数据，就会出现ORA 1555了，简单点来说就是找不到UNDO里面的前镜像了。 另外块清除会引起1555，不过这种情况是很少遇到的。 可以show parameter undo看一下这几个参数的值。 还有如果你的UNDO表空间过于小，那可能一般的普通操作都会报出这个错，大家一定要设置合理，避免此类错误。 哈哈，既然关系到UNDO，那么再简单说下UNDO吧，首先有几个数据字典和动态性能视图：v$undostat,DBA_ROLLBACK_SEGS,DBA_UNDO_EXTENTS,还有一个v$TRANSACTION，记录了事务的一些信息，还有回滚的数量。 UNDO其实就是记录删除或者更新操作的数据，顾名思义就是为了回滚，这里和REDO是紧密相连的，这里涉及到UNDO的REDO,因为事务其实都是先写UNDO，再写REDO的，也就是UNDO的REDO（记录UNDO块的修改）和REDO的redo（记录普通数据文件的修改）是所有的REDO。那么UNDO这里只是做一个简单的了解。 大家一定要记得在insert的时候，如果列上有索引，即使nologging，那么还是会导致大量的UNDO，因为在插入数据的时候会调整索引，那么肯定会产生大量的UNDO。delete和update是必走内存的，所以始终还是会记录REDO。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle listener]]></title>
    <url>%2F2011%2F07%2F21%2Foracle-listener%2F</url>
    <content type="text"><![CDATA[这一块知识，我相信搞oracle的兄弟都是比较精通的，我也是前段时间公司让做个培训的时候，又把这块又温习了一遍，还是有不少新的收获，今天就搬到这里记录一下大家可以看到这里的WEB应用充当中间件，既懂HTTP，又懂oracle net，厉害吧，其实就是个翻译官。如果WEB应用服务器采用 JDBC OCI DRIVER，那么WEB服务必须的安装oracle net组件，才能和oracle数据库进行通讯，走的TCP/IP协议。如果WEB应用服务是JDBC THIN DRIVER，也就是瘦客户端，那么不需要oracle net组件，只需要配置JAVA NET就可以和oracle进行通讯。监听怎么响应连接呢？看下图：衍生继承模式：当有连接请求时，listener接待，触发一个服务器进程，红框内3直接继承了listener，只能用在专有模式，listener关闭了不影响直接传送：使用Oracle Shared Server 时，监听程序将把连接传送给调度程序。专有模式不可用 重定向：listener和服务端不在同一台机器，比如RAC和共享服务 静态注册和动态注册： 1.动态注册：就是PMON主动把信息告诉监听，无需使用listener.ora将文件，lsnrclt status里面read的都是动态。 2.静态注册：监听主动去找服务和实例，需要配置listener.ora文件，指定SID列表，lsnrctl status里面是unknown 先看静态注册，很简单的，保证一看就懂 123456789101112131415161718192021222324252627直接配置listener.ora文件即可SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = oradb) (ORACLE_HOME = /app/oracle/product/10.2.0/db_1) ) )LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST =)(PORT = 1521)) ) ) 需要配置SID_NAME LISTENER需要指定相关参数块，这里如果host参数不指定，那么/etc/hosts需要指定，监听启动的时候回去读hosts文件匹配，如果设置为0.0.0.0，那么默认监听所有地址 动态注册以及配置： 1.动态注册不需要配置listener.ora文件，需要配置初始化参数文件，参数service_names,可是设置多个服务名，区分不同业务。 2.如果想配置非默认端口，非默认监听名称，非TCPIP协议，那么需要配置listener.ora 而且需要配置local_listener参数，tnsnames.ora也需要配置。 这里可以看到动态注册分为默认的和非默认的，默认的就是TCP/IP协议，端口是1521，监听名称LISTENER。非默认的大家自己能理解的哦。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748默认动态注册实验：1.Show parameter service_names;2.Alter system set service_names=zhang,hai,hong;3. Mv listener.ora listener.ora.bak Lsnrctl stop4.Lsnrctl start5.Alter system register;6.Lsnrctl service;看结果：Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=172.16.3.174)(PORT=1521)))Services Summary...Service &quot;HAI&quot; has 1 instance(s). Instance &quot;oradb&quot;, status READY, has 1 handler(s) for this service... Handler(s): &quot;DEDICATED&quot; established:0 refused:0 state:ready LOCAL SERVERService &quot;HONG&quot; has 1 instance(s). Instance &quot;oradb&quot;, status READY, has 1 handler(s) for this service... Handler(s): &quot;DEDICATED&quot; established:0 refused:0 state:ready LOCAL SERVERService &quot;ZHANG&quot; has 1 instance(s). Instance &quot;oradb&quot;, status READY, has 1 handler(s) for this service... Handler(s): &quot;DEDICATED&quot; established:0 refused:0 state:ready LOCAL SERVERService &quot;oradb&quot; has 2 instance(s). Instance &quot;oradb&quot;, status UNKNOWN, has 1 handler(s) for this service... Handler(s): &quot;DEDICATED&quot; established:0 refused:0 LOCAL SERVER Instance &quot;oradb&quot;, status READY, has 1 handler(s) for this service... Handler(s): &quot;DEDICATED&quot; established:0 refused:0 state:ready LOCAL SERVERService &quot;oradb_XPT&quot; has 1 instance(s). Instance &quot;oradb&quot;, status READY, has 1 handler(s) for this service... Handler(s): &quot;DEDICATED&quot; established:0 refused:0 state:ready LOCAL SERVERThe command completed successfully 相应的client端你如果是用oracle net组件的，那么肯定要配置tnsnames.ora文件123456789101112131415testdb =(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 172.168.3.174)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = zhang) )) 注意：标红的可以写zhang,hai,hong 或者oradb，就算木有listener.ora 文件，照样可以监听。 下面介绍下非默认动态注册： 这里我们端口用1234,非默认必须需要listener.ora 文件，还有就是local_listener参数. 修改监听文件：1234567891011121314151617# listener.ora Network Configuration File: /app/oracle/product/10.2.0/db_1/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = oradb) (ORACLE_HOME = /app/oracle/product/10.2.0/db_1) ) )LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST =172.16.3.174)(PORT = 1234)) ) ) 修改local_listener参数：Alter system set local_listener=‘(ADDRESS = (PROTOCOL = TCP)(HOST =)(PORT = 1234))’; 注意这里，以上修改参数等同于以下配置： 配置服务端的tnsnames.ora文件1234567891011hankzhang =(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST =)(PORT = 1234)) )) 然后再设置参数： Alter system set local_listener=hankzhang; 以上两种方法效果是一样滴。 lisnrctl status看一下：至于RAC的listener配置，呵呵，大同小异，不过还是有区别的，这里先提以下，有时间再继续。 RAC在监听端也可以负载均衡的哦，呵呵，当然这是在RAC双主模式的情况下，而且需要配置REMOTE_LISTENER，配置tnsnames.ora文件，监听暂时先到这里。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Installation from Source Code for postgreSQL]]></title>
    <url>%2F2010%2F09%2F18%2FInstallation-from-Source-Code-for-postgreSQL%2F</url>
    <content type="text"><![CDATA[其实学习pg有一段时间了，不过一直没有写相关的blog，以后这一块也会一起加进来，记录自己的学习过程。这里就先介绍下安装吧，pg安装还是很简单的，而且速度也快。1.和其他数据库安装一样，可以根据自己的需求，修改系统参数 /etc/sysctl.conf ,/etc/security/limits.conf,2.新建用户和组： #groupadd postgres #useradd -g postgres postgres3.创建相关目录： mkdir -p /database/pgdata/pg_root mkdir -p /opt/pgsql chown -R postgres:postgres /database/pgdata/pg_root 4.配置环境变量export PS1=”$USER@/bin/hostname -s-&gt; “export PGPORT=1921export PGDATA= /database/pgdata/pg_rootexport LANG=en_US.utf8export PGHOME=/opt/pgsqlexport LD_LIBRARY_PATH=$PGHOME/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/libexport DATE=date +&quot;%Y%m%d%H%M&quot;export PATH=$PGHOME/bin:$PATH:.export MANPATH=$PGHOME/share/man:$MANPATHalias rm=’rm -i’alias ll=’ls -lh’根据自己需求自己修改5.解压安装包，可以安装了 ./configure –help这个可以查看一下对应的帮助，根据自己的环境，适当选用一些参数./configure –prefix=/opt/pgsql –with-pgport=1921 –with-segsize=8 –with-wal-segsize=64 –with-wal-blocksize=64 –with-perl –with-python –with-openssl –with-pam –with-ldap –with-libxml –with-libxslt –enable-thread-safety gmake worldgmake install-world安装完成以后su - postgresinitdb -D /database/pgdata/pg_root初始化以后，可以启动数据库了通过postgres -D 或者pg_ctl -D后面跟对应的安装路径就可以了。]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
</search>
